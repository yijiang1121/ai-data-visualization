<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Grading Accuracy Dashboard</title>
    <style>
      :root {
        color-scheme: light dark;
        --bg: #f5f5f9;
        --card-bg: #ffffffcc;
        --card-shadow: rgba(15, 23, 42, 0.12);
        --text-primary: #0f172a;
        --text-secondary: #475569;
        --accent: #2563eb;
        --accent-soft: rgba(37, 99, 235, 0.12);
        --success: #059669;
        --warning: #d97706;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif;
        background: linear-gradient(160deg, var(--bg) 0%, #e2e8f0 100%);
        color: var(--text-primary);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        padding: 3rem 1.5rem 2rem;
        text-align: center;
      }

      header h1 {
        margin: 0 0 0.5rem;
        font-size: clamp(2rem, 5vw, 2.8rem);
        letter-spacing: -0.02em;
      }

      header p {
        margin: 0 auto;
        max-width: 48rem;
        color: var(--text-secondary);
        font-size: 1.05rem;
        line-height: 1.7;
      }

      main {
        flex: 1;
        padding: 0 1.5rem 3rem;
        max-width: 1100px;
        width: 100%;
        margin: 0 auto 3rem;
      }

      .summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 1.5rem;
        margin-bottom: 2.5rem;
      }

      .metric-card {
        background: var(--card-bg);
        border-radius: 1.25rem;
        box-shadow: 0 24px 48px -32px var(--card-shadow);
        padding: 2rem;
        position: relative;
        overflow: hidden;
      }

      .metric-card::after {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at top right, var(--accent-soft), transparent 55%);
        pointer-events: none;
      }

      .metric-title {
        font-size: 0.95rem;
        font-weight: 600;
        text-transform: uppercase;
        color: var(--text-secondary);
        letter-spacing: 0.08em;
        margin-bottom: 0.75rem;
      }

      .metric-value {
        font-size: clamp(2.5rem, 5vw, 3.5rem);
        font-weight: 700;
        margin: 0;
      }

      .metric-delta {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        margin-top: 1rem;
        font-size: 0.95rem;
        border-radius: 999px;
        padding: 0.35rem 0.9rem;
        font-weight: 600;
      }

      .metric-delta.positive {
        background: rgba(5, 150, 105, 0.12);
        color: var(--success);
      }

      .metric-delta.negative {
        background: rgba(217, 119, 6, 0.12);
        color: var(--warning);
      }

      .metric-subtitle {
        margin-top: 1.2rem;
        color: var(--text-secondary);
        font-size: 0.95rem;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .metric-footnote {
        font-size: 0.85rem;
      }

      section {
        margin-bottom: 2.5rem;
      }

      .section-heading {
        font-size: 1.4rem;
        margin-bottom: 0.5rem;
      }

      .section-subtitle {
        color: var(--text-secondary);
        margin-bottom: 1.5rem;
      }

      .table-wrapper {
        background: var(--card-bg);
        border-radius: 1rem;
        box-shadow: 0 18px 36px -28px var(--card-shadow);
        overflow: hidden;
      }

      .table-card {
        background: var(--card-bg);
        border-radius: 1rem;
        box-shadow: 0 18px 36px -28px var(--card-shadow);
        margin-bottom: 1.5rem;
        overflow: hidden;
      }

      .table-card .table-controls {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 1.25rem;
        border-bottom: 1px solid rgba(15, 23, 42, 0.08);
        font-size: 0.9rem;
        color: var(--text-secondary);
      }

      .table-card .table-controls label {
        font-weight: 600;
      }

      .table-card .table-controls select {
        appearance: none;
        border: none;
        border-radius: 999px;
        padding: 0.4rem 1.1rem;
        background: rgba(148, 163, 184, 0.2);
        color: var(--text-primary);
        font-weight: 600;
        cursor: pointer;
        font-size: 0.9rem;
      }

      .table-card .table-controls select:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .scale-toggle {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        gap: 0.75rem;
        margin: 0 0 2rem;
        font-size: 0.95rem;
        color: var(--text-secondary);
      }

      .scale-toggle label {
        font-weight: 600;
      }

      .scale-toggle select {
        appearance: none;
        border: none;
        border-radius: 999px;
        padding: 0.4rem 1.1rem;
        background: rgba(148, 163, 184, 0.2);
        color: var(--text-primary);
        font-weight: 600;
        cursor: pointer;
        font-size: 0.9rem;
      }

      .scale-toggle select:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .table-card .table-wrapper {
        background: transparent;
        box-shadow: none;
        border-radius: 0;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        min-width: 420px;
      }

      thead {
        background: rgba(37, 99, 235, 0.04);
      }

      th,
      td {
        padding: 1rem 1.25rem;
        text-align: left;
      }

      th {
        font-size: 0.85rem;
        text-transform: uppercase;
        color: var(--text-secondary);
        letter-spacing: 0.08em;
        font-weight: 600;
      }

      tbody tr {
        border-top: 1px solid rgba(15, 23, 42, 0.08);
      }

      tbody tr:nth-child(odd) {
        background: rgba(148, 163, 184, 0.08);
      }

      .muted {
        color: var(--text-secondary);
        font-size: 0.9rem;
      }

      .pill {
        display: inline-flex;
        padding: 0.25rem 0.65rem;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
        background: rgba(15, 23, 42, 0.08);
        color: var(--text-secondary);
        font-variant-numeric: tabular-nums;
      }

      .case-pill {
        display: inline-flex;
        align-items: center;
        padding: 0.25rem 0.7rem;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
        font-variant-numeric: tabular-nums;
      }

      .case-pill.success {
        background: rgba(5, 150, 105, 0.15);
        color: var(--success);
      }

      .case-pill.info {
        background: rgba(37, 99, 235, 0.15);
        color: var(--accent);
      }

      .case-pill.warning {
        background: rgba(217, 119, 6, 0.15);
        color: var(--warning);
      }

      .case-pill.secondary {
        background: rgba(148, 163, 184, 0.18);
        color: var(--text-secondary);
      }

      .case-pill + .case-pill {
        margin-top: 0.35rem;
      }

      .case-pill-wrapper {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        align-items: flex-start;
      }

      .table-strong {
        font-weight: 600;
        font-size: 1rem;
        font-variant-numeric: tabular-nums;
        margin-bottom: 0.35rem;
      }

      .insight-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 1.5rem;
        margin-bottom: 2rem;
      }

      .bar-chart {
        display: flex;
        flex-direction: column;
        gap: 1.1rem;
        margin-top: 1.25rem;
      }

      .bar-row {
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
      }

      .bar-row-header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 1rem;
        font-size: 0.95rem;
        font-weight: 600;
      }

      .bar-label {
        flex: 1;
      }

      .bar-value {
        font-variant-numeric: tabular-nums;
        color: var(--text-secondary);
        font-size: 0.9rem;
        white-space: nowrap;
      }

      .bar-track {
        height: 0.6rem;
        border-radius: 999px;
        background: rgba(148, 163, 184, 0.25);
        overflow: hidden;
      }

      .bar-fill {
        height: 100%;
        border-radius: inherit;
        background: var(--accent);
        transition: width 0.4s ease;
      }

      .bar-fill.success {
        background: rgba(5, 150, 105, 0.75);
      }

      .bar-fill.info {
        background: rgba(37, 99, 235, 0.75);
      }

      .bar-fill.warning {
        background: rgba(217, 119, 6, 0.75);
      }

      .error-message {
        background: rgba(248, 113, 113, 0.2);
        color: #b91c1c;
        padding: 1rem 1.25rem;
        border-radius: 0.75rem;
        margin-top: 1.5rem;
      }

      footer {
        text-align: center;
        padding: 2rem 1.5rem 3rem;
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      @media (max-width: 640px) {
        header {
          padding: 2.5rem 1rem 1.5rem;
        }

        main {
          padding: 0 1rem 2.5rem;
        }

        .metric-card {
          padding: 1.75rem;
        }

        .bar-row-header {
          flex-direction: column;
          align-items: flex-start;
          gap: 0.35rem;
        }

        .table-card .table-controls {
          flex-direction: column;
          align-items: flex-start;
        }

        .table-card .table-controls select {
          width: 100%;
        }

        .scale-toggle {
          justify-content: flex-start;
          flex-direction: column;
          align-items: flex-start;
          gap: 0.5rem;
        }

        .scale-toggle select {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Grading Accuracy Dashboard</h1>
      <p>
        Compare how closely the automated grading system and human reviewers align
        with the ground-truth labels. The metrics update automatically whenever
        the dataset is recomputed.
      </p>
    </header>

    <main>
      <div class="scale-toggle">
        <label for="breakdown-scale-select">Focus on scale</label>
        <select id="breakdown-scale-select">
          <option value="four_level">4-Point Detail</option>
          <option value="gnp">G / N / P</option>
        </select>
      </div>
      <section class="summary-grid" aria-live="polite">
        <article class="metric-card" id="autograder-card">
          <div class="metric-title">Autograder Accuracy</div>
          <p class="metric-value" id="autograder-accuracy">--</p>
          <div class="metric-subtitle">
            <span>Exact-match accuracy vs. ground truth</span>
            <span class="metric-footnote" id="autograder-sample">
              Based on -- automated evaluations.
            </span>
          </div>
        </article>

        <article class="metric-card" id="human-card">
          <div class="metric-title">Human Accuracy</div>
          <p class="metric-value" id="human-accuracy">--</p>
          <div class="metric-subtitle">
            <span>Exact-match accuracy vs. ground truth</span>
            <span class="metric-footnote" id="human-sample">
              Based on -- human reviews.
            </span>
          </div>
        </article>

        <article class="metric-card" id="dataset-card">
          <div class="metric-title">Evaluation Coverage</div>
          <p class="metric-value" id="total-evaluations">--</p>
          <div class="metric-subtitle">
            <span>Total human evaluations included in this refresh</span>
            <span class="metric-footnote" id="dataset-footnote">
              Across -- unique prompts.
            </span>
          </div>
        </article>
      </section>

      <section id="revision-section">
        <h2 class="section-heading">Revision insights</h2>
        <p class="section-subtitle">
          How often human reviewers revise the autograder and how those
          disagreements resolve against the ground truth.
        </p>

        <div class="insight-grid">
          <article class="metric-card" id="revision-overview-card">
            <div class="metric-title">Revision rate</div>
            <p class="metric-value" id="revision-rate">--</p>
            <div class="metric-subtitle">
              <span id="revision-volume">--</span>
              <span class="metric-footnote" id="revision-total">--</span>
            </div>
          </article>

          <article class="metric-card" id="revision-precision-card">
            <div class="metric-title">Revision precision</div>
            <p class="metric-value" id="revision-precision">--</p>
            <div class="metric-subtitle">
              <span id="revision-precision-detail">--</span>
              <span class="metric-footnote" id="revision-precision-footnote">--</span>
            </div>
          </article>
        </div>

        <article class="metric-card" id="revision-case-card">
          <div class="metric-title">Revision outcomes</div>
          <div
            id="revision-case-chart"
            class="bar-chart"
            role="list"
            aria-label="Revision outcome breakdown"
          >
            <div class="muted">Awaiting data…</div>
          </div>
          <div class="metric-subtitle">
            <span>Share of revisions by outcome vs. ground truth</span>
          </div>
        </article>

        <div class="table-card">
          <div class="table-controls">
            <label for="precision-slice-select">Focus on</label>
            <select id="precision-slice-select">
              <option value="disagreement">Human disagrees with autograder</option>
              <option value="agreement">Human agrees with autograder</option>
            </select>
            <label for="precision-breakdown-select">Break down by</label>
            <select id="precision-breakdown-select">
              <option value="ground_truth">Ground truth</option>
              <option value="autograder_label">Autograder label</option>
              <option value="human_label">Human label</option>
            </select>
          </div>
          <div class="table-wrapper">
            <table>
              <thead>
                <tr>
                  <th scope="col" id="precision-label-heading">Ground truth</th>
                  <th scope="col" id="precision-rate-heading">Revision rate</th>
                  <th scope="col" id="precision-count-heading">Revisions</th>
                  <th scope="col" id="precision-accuracy-heading">Revision precision</th>
                  <th scope="col" class="precision-case-heading" data-case-index="0">
                    Auto wrong → Human correct
                  </th>
                  <th scope="col" class="precision-case-heading" data-case-index="1">
                    Auto correct → Human wrong
                  </th>
                  <th scope="col" class="precision-case-heading" data-case-index="2">
                    Both wrong
                  </th>
                </tr>
              </thead>
              <tbody id="precision-table-body">
                <tr>
                  <td colspan="7" class="muted">Loading revision insights…</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div id="precision-empty" class="muted" hidden>
          No revision data available for this dataset.
        </div>
      </section>

      <section id="recall-section">
        <h2 class="section-heading">Autograder mistake recall</h2>
        <p class="section-subtitle">
          How effectively human revisions catch recurring autograder mistakes.
        </p>

        <article class="metric-card" id="autograder-recall-card">
          <div class="metric-title">Autograder mistake recall</div>
          <p class="metric-value" id="autograder-recall">--</p>
          <div class="metric-subtitle">
            <span id="autograder-recall-detail">--</span>
            <span class="metric-footnote" id="autograder-recall-footnote">--</span>
          </div>
          <div
            id="autograder-recall-chart"
            class="bar-chart"
            role="list"
            aria-label="Autograder mistake breakdown"
          >
            <div class="muted">Awaiting data…</div>
          </div>
        </article>

        <div class="table-card">
          <div class="table-controls">
            <label for="recall-breakdown-select">Break down by</label>
            <select id="recall-breakdown-select">
              <option value="ground_truth">Ground truth</option>
              <option value="autograder_label">Autograder label</option>
              <option value="human_label">Human label</option>
            </select>
          </div>
          <div class="table-wrapper">
            <table>
              <thead>
                <tr>
                  <th scope="col" id="recall-label-heading">Ground truth</th>
                  <th scope="col">Autograder mistake recall</th>
                  <th scope="col">Mistake evaluations</th>
                  <th scope="col">Corrected by human revision</th>
                  <th scope="col">No revision applied</th>
                  <th scope="col">Revised but still wrong</th>
                </tr>
              </thead>
              <tbody id="recall-table-body">
                <tr>
                  <td colspan="6" class="muted">Loading recall insights…</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div id="recall-empty" class="muted" hidden>
          No autograder mistake data available for this dataset.
        </div>
      </section>

      <section>
        <h2 class="section-heading">Prompt-level breakdown</h2>
        <p class="section-subtitle">
          Identify where the autograder excels or needs calibration compared with
          human reviewers.
        </p>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th scope="col">Prompt</th>
                <th scope="col">Responses</th>
                <th scope="col">Autograder</th>
                <th scope="col">Human</th>
                <th scope="col">Δ (Auto − Human)</th>
              </tr>
            </thead>
            <tbody id="prompt-table-body">
              <tr>
                <td colspan="5" class="muted">Loading metrics…</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div id="prompt-empty" class="muted" hidden>
          No prompt-level breakdown is available for this dataset.
        </div>
        <div id="error" class="error-message" hidden></div>
      </section>
    </main>

    <footer>
      Accuracy is computed by the Python metrics pipeline. Refresh this page after
      regenerating <code>accuracy.json</code> to see the latest numbers.
    </footer>

    <script>
      const autograderAccuracyEl = document.getElementById("autograder-accuracy");
      const humanAccuracyEl = document.getElementById("human-accuracy");
      const totalEvaluationsEl = document.getElementById("total-evaluations");
      const autograderSampleEl = document.getElementById("autograder-sample");
      const humanSampleEl = document.getElementById("human-sample");
      const datasetFootnoteEl = document.getElementById("dataset-footnote");
      const promptTableBody = document.getElementById("prompt-table-body");
      const promptEmpty = document.getElementById("prompt-empty");
      const errorEl = document.getElementById("error");
      const revisionSection = document.getElementById("revision-section");
      const recallSection = document.getElementById("recall-section");
      const revisionRateEl = document.getElementById("revision-rate");
      const revisionVolumeEl = document.getElementById("revision-volume");
      const revisionTotalEl = document.getElementById("revision-total");
      const revisionPrecisionEl = document.getElementById("revision-precision");
      const revisionPrecisionDetailEl = document.getElementById(
        "revision-precision-detail"
      );
      const revisionPrecisionFootnoteEl = document.getElementById(
        "revision-precision-footnote"
      );
      const autograderRecallEl = document.getElementById("autograder-recall");
      const autograderRecallDetailEl = document.getElementById(
        "autograder-recall-detail"
      );
      const autograderRecallFootnoteEl = document.getElementById(
        "autograder-recall-footnote"
      );
      const autograderRecallChartEl = document.getElementById(
        "autograder-recall-chart"
      );
      const revisionCaseChartEl = document.getElementById("revision-case-chart");
      const precisionTableBody = document.getElementById("precision-table-body");
      const precisionEmpty = document.getElementById("precision-empty");
      const precisionLabelHeading = document.getElementById("precision-label-heading");
      const precisionRateHeading = document.getElementById("precision-rate-heading");
      const precisionCountHeading = document.getElementById("precision-count-heading");
      const precisionAccuracyHeading = document.getElementById(
        "precision-accuracy-heading"
      );
      const precisionCaseHeadings = document.querySelectorAll(
        ".precision-case-heading"
      );
      const precisionSliceSelect = document.getElementById(
        "precision-slice-select"
      );
      const precisionBreakdownSelect = document.getElementById(
        "precision-breakdown-select"
      );
      const recallTableBody = document.getElementById("recall-table-body");
      const recallEmpty = document.getElementById("recall-empty");
      const recallLabelHeading = document.getElementById("recall-label-heading");
      const recallBreakdownSelect = document.getElementById("recall-breakdown-select");
      const breakdownScaleSelect = document.getElementById("breakdown-scale-select");

      const CASE_LABELS = {
        autograder_wrong_human_correct: "Autograder wrong → human corrected",
        autograder_correct_human_wrong: "Autograder correct → human wrong",
        both_wrong: "Both graders wrong",
      };

      const CASE_CLASS_MAP = {
        autograder_wrong_human_correct: "success",
        autograder_correct_human_wrong: "info",
        both_wrong: "warning",
      };

      const CASE_ORDER = [
        ["autograder_wrong_human_correct", "success"],
        ["autograder_correct_human_wrong", "info"],
        ["both_wrong", "warning"],
      ];

      const PRECISION_MAX_CASE_COLUMNS =
        (precisionCaseHeadings && precisionCaseHeadings.length) || 3;
      const PRECISION_DEFAULT_SLICE = "disagreement";
      const PRECISION_SLICE_CONFIGS = {
        disagreement: {
          label: "Human disagrees with autograder",
          rateLabel: "Revision rate",
          countLabel: "Revisions",
          countUnit: ["revision", "revisions"],
          correctUnit: ["correct revision", "correct revisions"],
          precisionLabel: "Revision precision",
          precisionDetailLabel: "revisions",
          rateField: "revision_rate",
          countField: "revision_count",
          precisionField: "correct_revision_precision",
          correctCountField: "correct_revision_count",
          caseShareField: "share_of_revisions",
          shareLabel: "of revisions",
          emptyMessage: "No revision data available.",
          datasetEmptyMessage:
            "No revision data available for this dataset.",
          cases: [
            {
              key: "autograder_wrong_human_correct",
              label: "Auto wrong → Human correct",
              variant: "success",
              shareField: "share_of_revisions",
            },
            {
              key: "autograder_correct_human_wrong",
              label: "Auto correct → Human wrong",
              variant: "info",
              shareField: "share_of_revisions",
            },
            {
              key: "both_wrong",
              label: "Both wrong",
              variant: "warning",
              shareField: "share_of_revisions",
            },
          ],
        },
        agreement: {
          label: "Human agrees with autograder",
          rateLabel: "Agreement rate",
          countLabel: "Agreements",
          countUnit: ["agreement", "agreements"],
          correctUnit: ["correct agreement", "correct agreements"],
          precisionLabel: "Agreement accuracy",
          precisionDetailLabel: "agreements",
          rateField: "agreement_rate",
          countField: "agreement_count",
          precisionField: "agreement_accuracy",
          correctCountField: "correct_agreement_count",
          caseShareField: "share_of_agreements",
          shareLabel: "of agreements",
          emptyMessage: "No agreement data available.",
          datasetEmptyMessage:
            "No agreement data available for this dataset.",
          cases: [
            {
              key: "both_correct",
              label: "Both correct vs. ground truth",
              variant: "success",
              shareField: "share_of_agreements",
            },
            {
              key: "both_wrong",
              label: "Both wrong vs. ground truth",
              variant: "warning",
              shareField: "share_of_agreements",
            },
          ],
        },
      };

      const AUTOGRADER_BREAKDOWN_META = {
        corrected: {
          label: "Corrected by human revision",
          variant: "success",
        },
        not_revised: {
          label: "No revision applied",
          variant: "info",
        },
        revised_but_wrong: {
          label: "Revised but still wrong",
          variant: "warning",
        },
      };

      const AUTOGRADER_BREAKDOWN_ORDER = [
        "corrected",
        "not_revised",
        "revised_but_wrong",
      ];

      const BREAKDOWN_LABELS = {
        ground_truth: "Ground truth",
        autograder_label: "Autograder label",
        human_label: "Human label",
      };

      let accuracyDataCache = null;
      let revisionDataCache = null;

      function getCombinedScaleLabels() {
        return {
          four_level: "4-Point Detail",
          gnp: "G / N / P",
          ...(accuracyDataCache?.scale_labels || {}),
          ...(revisionDataCache?.scale_labels || {}),
        };
      }

      function getAvailableScaleKeys() {
        const accuracyScales = accuracyDataCache?.scales
          ? Object.keys(accuracyDataCache.scales)
          : [];
        const revisionScales = revisionDataCache?.scales
          ? Object.keys(revisionDataCache.scales)
          : [];
        return Array.from(new Set([...accuracyScales, ...revisionScales]));
      }

      function getDefaultScaleKey() {
        const available = getAvailableScaleKeys();
        const preferences = [
          revisionDataCache?.default_scale,
          accuracyDataCache?.default_scale,
          "four_level",
        ];
        for (const key of preferences) {
          if (key && available.includes(key)) {
            return key;
          }
        }
        return available[0] || "four_level";
      }

      if (precisionBreakdownSelect) {
        precisionBreakdownSelect.addEventListener("change", () => {
          renderPrecisionTable();
        });
      }

      if (precisionSliceSelect) {
        precisionSliceSelect.addEventListener("change", () => {
          renderPrecisionTable();
        });
      }

      if (recallBreakdownSelect) {
        recallBreakdownSelect.addEventListener("change", () => {
          renderRecallTable();
        });
      }

      if (breakdownScaleSelect) {
        breakdownScaleSelect.addEventListener("change", () => {
          renderSummaryCards();
          renderRevisionOverview();
          renderPrecisionTable();
          renderRecallTable();
        });
      }

      function formatPercent(value) {
        if (value === null || value === undefined) {
          return "--";
        }
        return `${(value * 100).toFixed(1)}%`;
      }

      function formatCount(count) {
        if (!Number.isFinite(count)) {
          return "--";
        }
        return count.toLocaleString();
      }

      function formatEvaluationSource(count, descriptor) {
        if (!Number.isFinite(count)) {
          return "Evaluation count unavailable.";
        }
        const [singular, plural] = Array.isArray(descriptor)
          ? descriptor
          : [descriptor, descriptor];
        const noun = count === 1 ? singular : plural;
        return `Based on ${formatCount(count)} ${noun}.`;
      }

      function formatPromptSummary(totalEvaluations, uniquePrompts) {
        if (!Number.isFinite(uniquePrompts) || uniquePrompts <= 0) {
          return "Unique prompt count unavailable.";
        }
        const promptLabel = uniquePrompts === 1 ? "unique prompt" : "unique prompts";
        const parts = [`Across ${formatCount(uniquePrompts)} ${promptLabel}`];
        if (Number.isFinite(totalEvaluations) && totalEvaluations > 0) {
          const average = totalEvaluations / uniquePrompts;
          if (Number.isFinite(average)) {
            parts.push(`≈${average.toFixed(1)} reviews per prompt`);
          }
        }
        return parts.join(" · ");
      }

      function formatLabel(label) {
        if (label === null || label === undefined) {
          return "—";
        }
        const text = String(label).trim();
        if (!text) {
          return "—";
        }
        if (/[A-Z]/.test(text)) {
          return text;
        }
        return text
          .split(/\s+/)
          .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
          .join(" ");
      }

      function getRevisionDefaultScale(revision) {
        if (!revision) {
          return "four_level";
        }
        const scales = revision?.scales || {};
        const keys = Object.keys(scales);
        if (
          revision.default_scale &&
          keys.includes(revision.default_scale)
        ) {
          return revision.default_scale;
        }
        if (keys.length) {
          return keys[0];
        }
        return "four_level";
      }

      function getRevisionScaleData(revision, scaleKey) {
        if (!revision) {
          return null;
        }
        const scales = revision.scales;
        if (
          scales &&
          scaleKey &&
          Object.prototype.hasOwnProperty.call(scales, scaleKey)
        ) {
          return scales[scaleKey];
        }
        if (scales) {
          const fallbackKey = getRevisionDefaultScale(revision);
          if (Object.prototype.hasOwnProperty.call(scales, fallbackKey)) {
            return scales[fallbackKey];
          }
        }
        return {
          overall: revision.overall || {},
          cases: revision.cases || {},
          autograder_wrong_breakdown: revision.autograder_wrong_breakdown || {},
          breakdowns: revision.breakdowns || {},
          agreement: revision.agreement || {},
          slices: revision.slices || {},
        };
      }

      function getAccuracyScaleData(accuracy, scaleKey) {
        if (!accuracy) {
          return null;
        }
        const scales = accuracy.scales || {};
        if (
          scaleKey &&
          Object.prototype.hasOwnProperty.call(scales, scaleKey)
        ) {
          return scales[scaleKey];
        }
        if (
          accuracy.default_scale &&
          Object.prototype.hasOwnProperty.call(scales, accuracy.default_scale)
        ) {
          return scales[accuracy.default_scale];
        }
        return {
          summary: accuracy.summary || {},
          per_prompt: accuracy.per_prompt || [],
        };
      }

      function getSelectedScaleKey() {
        const available = getAvailableScaleKeys();
        const requested = breakdownScaleSelect?.value;
        if (requested && available.includes(requested)) {
          return requested;
        }
        const fallback = getDefaultScaleKey();
        if (breakdownScaleSelect && fallback) {
          breakdownScaleSelect.value = fallback;
        }
        return fallback;
      }

      function updateBreakdownScaleSelectOptions() {
        if (!breakdownScaleSelect) {
          return false;
        }

        const labels = getCombinedScaleLabels();
        const available = getAvailableScaleKeys();
        const defaultScale = getDefaultScaleKey();
        let selectionChanged = false;

        Array.from(breakdownScaleSelect.options || []).forEach((option) => {
          const value = option.value;
          if (!value) {
            return;
          }

          if (labels[value]) {
            option.textContent = labels[value];
          }

          if (!available.length) {
            option.disabled = false;
            return;
          }

          option.disabled = !available.includes(value);
        });

        breakdownScaleSelect.disabled = available.length === 0;

        if (available.length) {
          if (!available.includes(breakdownScaleSelect.value) && defaultScale) {
            breakdownScaleSelect.value = defaultScale;
            selectionChanged = true;
          }
        } else if (
          defaultScale &&
          breakdownScaleSelect.value !== defaultScale
        ) {
          breakdownScaleSelect.value = defaultScale;
          selectionChanged = true;
        }

        return selectionChanged;
      }

      function getSelectedBreakdown(selectEl) {
        const value = selectEl?.value;
        if (
          value &&
          Object.prototype.hasOwnProperty.call(BREAKDOWN_LABELS, value)
        ) {
          return value;
        }
        return "ground_truth";
      }

      function getBreakdownHeading(key, scaleKey) {
        const base = BREAKDOWN_LABELS[key] || "Segment";
        const labels = revisionDataCache?.scale_labels || {};
        const scaleLabel = labels?.[scaleKey];
        return scaleLabel ? `${base} (${scaleLabel})` : base;
      }

      function getPrecisionSliceKey() {
        const requested = precisionSliceSelect?.value;
        if (
          requested &&
          Object.prototype.hasOwnProperty.call(
            PRECISION_SLICE_CONFIGS,
            requested
          )
        ) {
          return requested;
        }
        if (precisionSliceSelect) {
          precisionSliceSelect.value = PRECISION_DEFAULT_SLICE;
        }
        return PRECISION_DEFAULT_SLICE;
      }

      function getPrecisionSliceConfig(sliceKey) {
        if (
          sliceKey &&
          Object.prototype.hasOwnProperty.call(
            PRECISION_SLICE_CONFIGS,
            sliceKey
          )
        ) {
          return PRECISION_SLICE_CONFIGS[sliceKey];
        }
        return PRECISION_SLICE_CONFIGS[PRECISION_DEFAULT_SLICE];
      }

      function updatePrecisionHeaders(sliceConfig, breakdownHeading) {
        if (precisionLabelHeading) {
          precisionLabelHeading.textContent = breakdownHeading;
        }
        if (precisionRateHeading) {
          precisionRateHeading.textContent = sliceConfig.rateLabel;
        }
        if (precisionCountHeading) {
          precisionCountHeading.textContent = sliceConfig.countLabel;
        }
        if (precisionAccuracyHeading) {
          precisionAccuracyHeading.textContent = sliceConfig.precisionLabel;
        }
        precisionCaseHeadings.forEach((heading, index) => {
          if (!heading) {
            return;
          }
          const caseMeta = sliceConfig.cases[index];
          heading.textContent = caseMeta ? caseMeta.label : "—";
        });
      }

      function getBreakdownEntries(
        revision,
        key,
        scaleKey,
        sliceKey = PRECISION_DEFAULT_SLICE
      ) {
        const scaleData = getRevisionScaleData(revision, scaleKey);
        const sliceData = scaleData?.slices?.[sliceKey];
        if (sliceData?.breakdowns?.[key]) {
          return sliceData.breakdowns[key];
        }
        if (sliceKey === "disagreement") {
          return scaleData?.breakdowns?.[key] || [];
        }
        return [];
      }

      function resolveBreakdownLabel(entry) {
        if (!entry) {
          return "—";
        }
        return (
          entry.label_display ||
          entry.ground_truth_display ||
          entry.autograder_label_display ||
          entry.human_label_display ||
          formatLabel(
            entry.label ||
              entry.ground_truth ||
              entry.autograder_label ||
              entry.human_label
          )
        );
      }

      function computeMistakeRepetitionFactor(source) {
        const factor = source?.overall?.mistake_repetition_factor;
        return Number.isFinite(factor) && factor > 0 ? factor : 1;
      }

      function renderDelta(subject, comparison, subjectLabel, comparisonLabel) {
        const container = document.createElement("span");
        container.classList.add("metric-delta");
        const diff = subject - comparison;
        const formatted = `${diff > 0 ? "+" : ""}${(diff * 100).toFixed(1)}%`;
        container.textContent = `Δ vs. ${comparisonLabel}: ${formatted}`;
        container.title = `${subjectLabel} accuracy minus ${comparisonLabel.toLowerCase()} accuracy`;
        container.setAttribute(
          "aria-label",
          `${subjectLabel} accuracy compared with ${comparisonLabel.toLowerCase()} accuracy`
        );
        if (diff >= 0) {
          container.classList.add("positive");
        } else {
          container.classList.add("negative");
        }
        return container;
      }

      function updateCards(summary = {}) {
        autograderAccuracyEl.textContent = formatPercent(summary.autograder_accuracy);
        humanAccuracyEl.textContent = formatPercent(summary.human_accuracy);
        totalEvaluationsEl.textContent = formatCount(summary.total_evaluations);

        if (autograderSampleEl) {
          autograderSampleEl.textContent = formatEvaluationSource(
            summary.autograder_evaluations,
            ["automated prompt evaluation", "automated prompt evaluations"]
          );
        }

        if (humanSampleEl) {
          humanSampleEl.textContent = formatEvaluationSource(
            summary.human_evaluations,
            ["human review", "human reviews"]
          );
        }

        if (datasetFootnoteEl) {
          datasetFootnoteEl.textContent = formatPromptSummary(
            summary.total_evaluations,
            summary.unique_prompts
          );
        }

        const autograderCard = document.getElementById("autograder-card");
        const humanCard = document.getElementById("human-card");

        [autograderCard, humanCard].forEach((card) => {
          if (!card) {
            return;
          }
          const existingDelta = card.querySelector(".metric-delta");
          if (existingDelta) {
            existingDelta.remove();
          }
        });

        if (
          summary.autograder_accuracy !== null &&
          summary.autograder_accuracy !== undefined &&
          summary.human_accuracy !== null &&
          summary.human_accuracy !== undefined
        ) {
          humanCard.appendChild(
            renderDelta(
              summary.human_accuracy,
              summary.autograder_accuracy,
              "Human",
              "Autograder"
            )
          );
          autograderCard.appendChild(
            renderDelta(
              summary.autograder_accuracy,
              summary.human_accuracy,
              "Autograder",
              "Human"
            )
          );
        }
      }

      function renderSummaryCards() {
        if (!accuracyDataCache) {
          return;
        }

        const scaleKey = getSelectedScaleKey();
        const scaleData =
          getAccuracyScaleData(accuracyDataCache, scaleKey) || {};
        const summary =
          scaleData?.summary || accuracyDataCache.summary || {};
        const promptEntries =
          scaleData?.per_prompt || accuracyDataCache.per_prompt || [];

        updateCards(summary);
        updatePromptTable(promptEntries);
      }

      function renderRevisionCases(cases = {}, totalRevisions = 0) {
        if (!revisionCaseChartEl) {
          return;
        }
        revisionCaseChartEl.innerHTML = "";
        const hasRevisions = totalRevisions > 0;
        const entries = Object.keys(CASE_LABELS).map((key) => {
          const caseData = cases?.[key] || {};
          const count = Number.isFinite(caseData.count) ? caseData.count : 0;
          const shareValue = Number.isFinite(caseData.share_of_revisions)
            ? caseData.share_of_revisions
            : hasRevisions
            ? count / totalRevisions
            : 0;
          return {
            key,
            label: CASE_LABELS[key],
            count,
            share: Math.max(0, Math.min(shareValue, 1)),
          };
        });

        if (!hasRevisions) {
          const message = document.createElement("div");
          message.className = "muted";
          message.textContent = "No revisions recorded in this dataset.";
          revisionCaseChartEl.appendChild(message);
          return;
        }

        entries.forEach((entry) => {
          const row = document.createElement("div");
          row.className = "bar-row";
          row.setAttribute("role", "listitem");

          const header = document.createElement("div");
          header.className = "bar-row-header";

          const labelEl = document.createElement("span");
          labelEl.className = "bar-label";
          labelEl.textContent = entry.label;
          header.appendChild(labelEl);

          const percentText = `${(entry.share * 100).toFixed(1)}%`;
          const valueEl = document.createElement("span");
          valueEl.className = "bar-value";
          valueEl.textContent = `${formatCount(entry.count)} · ${percentText}`;
          header.appendChild(valueEl);

          row.appendChild(header);

          const track = document.createElement("div");
          track.className = "bar-track";

          const fill = document.createElement("div");
          fill.className = `bar-fill ${CASE_CLASS_MAP[entry.key] || ""}`.trim();
          fill.style.width = `${(entry.share * 100).toFixed(1)}%`;
          fill.setAttribute(
            "aria-label",
            `${entry.label}: ${percentText} of revisions`
          );
          track.appendChild(fill);

          row.appendChild(track);
          revisionCaseChartEl.appendChild(row);
        });
      }

      function renderAutograderRecallBreakdown(
        breakdown = {},
        totalMistakes = 0,
        repetitionFactor = 1
      ) {
        if (!autograderRecallChartEl) {
          return;
        }
        autograderRecallChartEl.innerHTML = "";
        const hasMistakes = Number.isFinite(totalMistakes) && totalMistakes > 0;

        const factor =
          Number.isFinite(repetitionFactor) && repetitionFactor > 0
            ? repetitionFactor
            : 1;

        if (!hasMistakes) {
          const message = document.createElement("div");
          message.className = "muted";
          message.textContent = "No autograder mistakes recorded.";
          autograderRecallChartEl.appendChild(message);
          return;
        }

        AUTOGRADER_BREAKDOWN_ORDER.forEach((key) => {
          const entryMeta = AUTOGRADER_BREAKDOWN_META[key] || {
            label: key,
            variant: "",
          };
          const data = breakdown?.[key] || {};
          const count = Number.isFinite(data.count) ? data.count : 0;
          const shareValue = Number.isFinite(data.share_of_autograder_wrong)
            ? data.share_of_autograder_wrong
            : count / totalMistakes;
          const share = Math.max(0, Math.min(shareValue, 1));
          const displayCount = count * factor;

          const row = document.createElement("div");
          row.className = "bar-row";
          row.setAttribute("role", "listitem");

          const header = document.createElement("div");
          header.className = "bar-row-header";

          const labelEl = document.createElement("span");
          labelEl.className = "bar-label";
          labelEl.textContent = entryMeta.label;
          header.appendChild(labelEl);

          const percentText = `${(share * 100).toFixed(1)}%`;
          const valueEl = document.createElement("span");
          valueEl.className = "bar-value";
          valueEl.textContent = `${formatCount(displayCount)} · ${percentText}`;
          header.appendChild(valueEl);

          row.appendChild(header);

          const track = document.createElement("div");
          track.className = "bar-track";

          const fill = document.createElement("div");
          const variantClass = entryMeta.variant ? ` ${entryMeta.variant}` : "";
          fill.className = `bar-fill${variantClass}`;
          fill.style.width = `${(share * 100).toFixed(1)}%`;
          fill.setAttribute(
            "aria-label",
            `${entryMeta.label}: ${percentText} of autograder mistakes (${formatCount(
              displayCount
            )} evaluations)`
          );
          track.appendChild(fill);

          row.appendChild(track);
          autograderRecallChartEl.appendChild(row);
        });
      }

      function renderRevisionOverview() {
        if (!revisionDataCache) {
          return;
        }

        const scaleKey = getSelectedScaleKey();
        const scaleData =
          getRevisionScaleData(revisionDataCache, scaleKey) || {};
        const overall =
          scaleData?.overall || revisionDataCache.overall || {};
        const cases =
          scaleData?.cases || revisionDataCache.cases || {};
        const autograderBreakdown =
          scaleData?.autograder_wrong_breakdown ||
          revisionDataCache.autograder_wrong_breakdown ||
          {};

        const revisionCount = Number.isFinite(overall.revision_count)
          ? overall.revision_count
          : 0;
        const totalEvaluations = Number.isFinite(overall.total_evaluations)
          ? overall.total_evaluations
          : null;
        const correctRevisionCount = Number.isFinite(
          overall.correct_revision_count
        )
          ? overall.correct_revision_count
          : 0;
        const autograderMistakeTotal = Number.isFinite(
          overall.autograder_wrong_total
        )
          ? overall.autograder_wrong_total
          : 0;
        const correctedMistakes = Number.isFinite(
          overall.corrected_autograder_wrong
        )
          ? overall.corrected_autograder_wrong
          : 0;

        const repetitionFactor = computeMistakeRepetitionFactor(scaleData);
        const displayTotalMistakes = autograderMistakeTotal * repetitionFactor;
        const displayCorrectedMistakes =
          correctedMistakes * repetitionFactor;

        if (revisionRateEl) {
          revisionRateEl.textContent = formatPercent(overall.revision_rate);
        }
        if (revisionVolumeEl) {
          revisionVolumeEl.textContent = `${formatCount(
            revisionCount
          )} revisions`;
        }
        if (revisionTotalEl) {
          if (totalEvaluations !== null) {
            const noun =
              totalEvaluations === 1 ? "human review" : "human reviews";
            revisionTotalEl.textContent = `Out of ${formatCount(
              totalEvaluations
            )} ${noun}`;
          } else {
            revisionTotalEl.textContent = "Total human reviews unavailable.";
          }
        }

        if (revisionPrecisionEl) {
          revisionPrecisionEl.textContent = formatPercent(
            overall.correct_revision_precision
          );
        }
        if (revisionPrecisionDetailEl) {
          revisionPrecisionDetailEl.textContent = `${formatCount(
            correctRevisionCount
          )} correct revisions`;
        }
        if (revisionPrecisionFootnoteEl) {
          if (revisionCount) {
            revisionPrecisionFootnoteEl.textContent = `Out of ${formatCount(
              revisionCount
            )} total revisions.`;
          } else {
            revisionPrecisionFootnoteEl.textContent =
              "No revisions recorded.";
          }
        }

        if (autograderRecallEl) {
          autograderRecallEl.textContent = formatPercent(
            overall.autograder_wrong_recall
          );
        }
        if (autograderRecallDetailEl) {
          autograderRecallDetailEl.textContent = `${formatCount(
            displayCorrectedMistakes
          )} mistake evaluations corrected`;
        }
        if (autograderRecallFootnoteEl) {
          if (autograderMistakeTotal) {
            const noun =
              autograderMistakeTotal === 1 ? "mistake" : "mistakes";
            if (repetitionFactor > 1) {
              autograderRecallFootnoteEl.textContent = `Out of ${formatCount(
                displayTotalMistakes
              )} autograder mistake evaluations (${repetitionFactor}× ${formatCount(
                autograderMistakeTotal
              )} ${noun}).`;
            } else {
              autograderRecallFootnoteEl.textContent = `Out of ${formatCount(
                autograderMistakeTotal
              )} autograder ${noun}.`;
            }
          } else {
            autograderRecallFootnoteEl.textContent =
              "No autograder mistakes detected.";
          }
        }

        renderRevisionCases(cases, revisionCount);
        renderAutograderRecallBreakdown(
          autograderBreakdown,
          autograderMistakeTotal,
          repetitionFactor
        );
      }

      function createCaseCell(entry, caseMeta, sliceConfig) {
        const cell = document.createElement("td");
        const caseData = entry?.cases?.[caseMeta.key] || {};
        const count = Number.isFinite(caseData.count) ? caseData.count : 0;
        const baseCount = Number.isFinite(entry?.[sliceConfig.countField])
          ? entry[sliceConfig.countField]
          : 0;
        const shareField = caseMeta.shareField || sliceConfig.caseShareField;
        let shareValue = Number.isFinite(caseData[shareField])
          ? caseData[shareField]
          : null;
        if (shareValue === null && baseCount > 0) {
          shareValue = count / baseCount;
        }
        if (!Number.isFinite(shareValue)) {
          shareValue = 0;
        }
        const clampedShare = Math.max(0, Math.min(shareValue, 1));

        const countEl = document.createElement("div");
        countEl.className = "table-strong";
        countEl.textContent = formatCount(count);
        cell.appendChild(countEl);

        const pillWrapper = document.createElement("div");
        pillWrapper.className = "case-pill-wrapper";

        const shareEl = document.createElement("span");
        const variantClass = caseMeta.variant ? ` ${caseMeta.variant}` : "";
        shareEl.className = `case-pill${variantClass}`;
        const shareLabel = caseMeta.shareLabel || sliceConfig.shareLabel || "";
        const shareSuffix = shareLabel ? ` ${shareLabel}` : "";
        const shareText = `${(clampedShare * 100).toFixed(1)}%${shareSuffix}`.trim();
        shareEl.textContent = shareText;
        pillWrapper.appendChild(shareEl);

        cell.appendChild(pillWrapper);

        return cell;
      }

      function createPrecisionPlaceholderCell() {
        const cell = document.createElement("td");
        cell.className = "muted";
        cell.textContent = "—";
        return cell;
      }

      function computePrecisionTotals(entries = [], sliceConfig) {
        if (!entries?.length) {
          return null;
        }

        const totals = {
          label_display: "Total",
          total_evaluations: 0,
          cases: {},
        };

        const countField = sliceConfig.countField;
        const correctField = sliceConfig.correctCountField;
        const rateField = sliceConfig.rateField;
        const precisionField = sliceConfig.precisionField;

        totals[countField] = 0;
        totals[correctField] = 0;

        entries.forEach((entry) => {
          if (!entry) {
            return;
          }

          const sliceCount = Number.isFinite(entry[countField])
            ? entry[countField]
            : 0;
          const totalEvaluations = Number.isFinite(entry.total_evaluations)
            ? entry.total_evaluations
            : 0;
          const correctCount = Number.isFinite(entry[correctField])
            ? entry[correctField]
            : 0;

          totals[countField] += sliceCount;
          totals.total_evaluations += totalEvaluations;
          totals[correctField] += correctCount;

          sliceConfig.cases.forEach((caseMeta) => {
            const caseKey = caseMeta.key;
            const caseData = entry?.cases?.[caseKey] || {};
            const caseCount = Number.isFinite(caseData.count)
              ? caseData.count
              : 0;
            totals.cases[caseKey] = (totals.cases[caseKey] || 0) + caseCount;
          });
        });

        const totalSliceCount = totals[countField];
        const totalEvaluations = totals.total_evaluations;

        totals[rateField] =
          totalEvaluations > 0 ? totalSliceCount / totalEvaluations : null;

        totals[precisionField] =
          totalSliceCount > 0 ? totals[correctField] / totalSliceCount : null;

        totals.cases = Object.fromEntries(
          sliceConfig.cases.map((caseMeta) => {
            const caseKey = caseMeta.key;
            const caseCount = totals.cases[caseKey] || 0;
            const shareField = caseMeta.shareField || sliceConfig.caseShareField;
            return [
              caseKey,
              {
                count: caseCount,
                ...(shareField
                  ? {
                      [shareField]:
                        totalSliceCount > 0
                          ? caseCount / totalSliceCount
                          : null,
                    }
                  : {}),
              },
            ];
          })
        );

        return totals;
      }

      function buildPrecisionRow(entry, sliceConfig) {
        if (!entry) {
          return document.createElement("tr");
        }

        const row = document.createElement("tr");

        const labelCell = document.createElement("td");
        labelCell.textContent = resolveBreakdownLabel(entry);
        row.appendChild(labelCell);

        const rateCell = document.createElement("td");
        rateCell.textContent = formatPercent(entry?.[sliceConfig.rateField]);
        row.appendChild(rateCell);

        const revisionsCell = document.createElement("td");
        const sliceCount = Number.isFinite(entry?.[sliceConfig.countField])
          ? entry[sliceConfig.countField]
          : 0;
        const totalEvaluations = Number.isFinite(entry.total_evaluations)
          ? entry.total_evaluations
          : 0;
        const countEl = document.createElement("div");
        countEl.className = "table-strong";
        countEl.textContent = formatCount(sliceCount);
        revisionsCell.appendChild(countEl);
        const subtitle = document.createElement("div");
        subtitle.className = "muted";
        subtitle.textContent = `${formatCount(totalEvaluations)} evaluations`;
        revisionsCell.appendChild(subtitle);
        row.appendChild(revisionsCell);

        const precisionCell = document.createElement("td");
        const precisionValue = document.createElement("div");
        precisionValue.className = "table-strong";
        precisionValue.textContent = formatPercent(
          entry?.[sliceConfig.precisionField]
        );
        precisionCell.appendChild(precisionValue);
        const precisionDetail = document.createElement("div");
        precisionDetail.className = "muted";
        const correctCount = Number.isFinite(
          entry?.[sliceConfig.correctCountField]
        )
          ? entry[sliceConfig.correctCountField]
          : 0;
        const countUnits = Array.isArray(sliceConfig.countUnit)
          ? sliceConfig.countUnit
          : ["item", "items"];
        const [countSingular, countPlural] = countUnits;
        const correctUnits = Array.isArray(sliceConfig.correctUnit)
          ? sliceConfig.correctUnit
          : [`correct ${countSingular}`, `correct ${countPlural}`];

        if (sliceCount) {
          const noun = sliceCount === 1 ? countSingular : countPlural;
          precisionDetail.textContent = `${formatCount(
            correctCount
          )} of ${formatCount(sliceCount)} ${noun}`;
        } else {
          const noun = correctCount === 1 ? correctUnits[0] : correctUnits[1];
          precisionDetail.textContent = `${formatCount(correctCount)} ${noun}`;
        }
        precisionCell.appendChild(precisionDetail);
        row.appendChild(precisionCell);

        for (let index = 0; index < PRECISION_MAX_CASE_COLUMNS; index += 1) {
          const caseMeta = sliceConfig.cases[index];
          if (caseMeta) {
            row.appendChild(createCaseCell(entry, caseMeta, sliceConfig));
          } else {
            row.appendChild(createPrecisionPlaceholderCell());
          }
        }

        return row;
      }

      function createRecallBreakdownCell(entry, breakdownKey, factor) {
        const cell = document.createElement("td");
        const breakdown = entry?.autograder_wrong_breakdown?.[breakdownKey] || {};
        const baseCount = Number.isFinite(breakdown.count) ? breakdown.count : 0;
        const displayCount = baseCount * factor;
        const shareOfMistakes = Number.isFinite(breakdown.share_of_autograder_wrong)
          ? breakdown.share_of_autograder_wrong
          : null;

        const countEl = document.createElement("div");
        countEl.className = "table-strong";
        countEl.textContent = formatCount(displayCount);
        cell.appendChild(countEl);

        const pillWrapper = document.createElement("div");
        pillWrapper.className = "case-pill-wrapper";

        if (shareOfMistakes !== null) {
          const variantClass =
            AUTOGRADER_BREAKDOWN_META[breakdownKey]?.variant || "";
          const sharePill = document.createElement("span");
          sharePill.className = `case-pill ${variantClass}`.trim();
          sharePill.textContent = `${(shareOfMistakes * 100).toFixed(1)}% of mistakes`;
          pillWrapper.appendChild(sharePill);
        }

        if (pillWrapper.childElementCount) {
          cell.appendChild(pillWrapper);
        }

        return cell;
      }

      function computeRecallTotals(entries = []) {
        if (!entries?.length) {
          return null;
        }

        const totals = {
          label_display: "Total",
          corrected_autograder_wrong: 0,
          autograder_wrong_total: 0,
          autograder_wrong_breakdown: {},
        };

        entries.forEach((entry) => {
          if (!entry) {
            return;
          }

          const corrected = Number.isFinite(entry.corrected_autograder_wrong)
            ? entry.corrected_autograder_wrong
            : 0;
          const totalMistakes = Number.isFinite(entry.autograder_wrong_total)
            ? entry.autograder_wrong_total
            : 0;

          totals.corrected_autograder_wrong += corrected;
          totals.autograder_wrong_total += totalMistakes;

          AUTOGRADER_BREAKDOWN_ORDER.forEach((key) => {
            const breakdown = entry?.autograder_wrong_breakdown?.[key] || {};
            const count = Number.isFinite(breakdown.count) ? breakdown.count : 0;
            totals.autograder_wrong_breakdown[key] =
              (totals.autograder_wrong_breakdown[key] || 0) + count;
          });
        });

        const totalMistakes = totals.autograder_wrong_total;
        totals.autograder_wrong_recall =
          totalMistakes > 0
            ? totals.corrected_autograder_wrong / totalMistakes
            : null;

        totals.autograder_wrong_breakdown = Object.fromEntries(
          AUTOGRADER_BREAKDOWN_ORDER.map((key) => {
            const count = totals.autograder_wrong_breakdown[key] || 0;
            return [
              key,
              {
                count,
                share_of_autograder_wrong:
                  totalMistakes > 0 ? count / totalMistakes : 0,
              },
            ];
          })
        );

        return totals;
      }

      function buildRecallRow(entry, factor) {
        if (!entry) {
          return document.createElement("tr");
        }

        const row = document.createElement("tr");

        const labelCell = document.createElement("td");
        labelCell.textContent = resolveBreakdownLabel(entry);
        row.appendChild(labelCell);

        const recallCell = document.createElement("td");
        const recallValue = document.createElement("div");
        recallValue.className = "table-strong";
        recallValue.textContent = formatPercent(entry.autograder_wrong_recall);
        recallCell.appendChild(recallValue);
        const recallDetail = document.createElement("div");
        recallDetail.className = "muted";
        const corrected = Number.isFinite(entry.corrected_autograder_wrong)
          ? entry.corrected_autograder_wrong
          : 0;
        const totalMistakes = Number.isFinite(entry.autograder_wrong_total)
          ? entry.autograder_wrong_total
          : 0;
        const correctedDisplay = corrected * factor;
        const totalDisplay = totalMistakes * factor;
        if (totalDisplay) {
          recallDetail.textContent = `${formatCount(
            correctedDisplay
          )} of ${formatCount(totalDisplay)} mistake evaluations`;
        } else {
          recallDetail.textContent = `${formatCount(
            correctedDisplay
          )} mistake evaluations`;
        }
        recallCell.appendChild(recallDetail);
        row.appendChild(recallCell);

        const totalCell = document.createElement("td");
        const totalValue = document.createElement("div");
        totalValue.className = "table-strong";
        totalValue.textContent = formatCount(totalDisplay);
        totalCell.appendChild(totalValue);
        const totalDetail = document.createElement("div");
        totalDetail.className = "muted";
        if (factor > 1 && totalMistakes) {
          totalDetail.textContent = `${factor}× ${formatCount(totalMistakes)} mistakes`;
        } else {
          totalDetail.textContent = `${formatCount(totalMistakes)} mistakes`;
        }
        totalCell.appendChild(totalDetail);
        row.appendChild(totalCell);

        AUTOGRADER_BREAKDOWN_ORDER.forEach((key) => {
          row.appendChild(createRecallBreakdownCell(entry, key, factor));
        });

        return row;
      }

      function renderPrecisionTable() {
        if (!precisionTableBody) {
          return;
        }

        precisionTableBody.innerHTML = "";

        const scaleKey = getSelectedScaleKey();
        const breakdownKey = getSelectedBreakdown(precisionBreakdownSelect);
        const sliceKey = getPrecisionSliceKey();
        const sliceConfig = getPrecisionSliceConfig(sliceKey);
        const breakdownHeading = getBreakdownHeading(breakdownKey, scaleKey);
        updatePrecisionHeaders(sliceConfig, breakdownHeading);

        const entries = getBreakdownEntries(
          revisionDataCache,
          breakdownKey,
          scaleKey,
          sliceKey
        );

        if (!entries || entries.length === 0) {
          if (precisionEmpty) {
            precisionEmpty.hidden = false;
            precisionEmpty.textContent =
              sliceConfig.datasetEmptyMessage ||
              "No data available for this dataset.";
          }
          const row = document.createElement("tr");
          const cell = document.createElement("td");
          cell.colSpan = 4 + PRECISION_MAX_CASE_COLUMNS;
          cell.className = "muted";
          cell.textContent = sliceConfig.emptyMessage || "No data available.";
          row.appendChild(cell);
          precisionTableBody.appendChild(row);
          return;
        }

        if (precisionEmpty) {
          precisionEmpty.hidden = true;
        }

        const rateField = sliceConfig.rateField;
        const sortedEntries = entries
          .slice()
          .sort((a, b) => (b?.[rateField] ?? 0) - (a?.[rateField] ?? 0));

        sortedEntries.forEach((entry) => {
          precisionTableBody.appendChild(
            buildPrecisionRow(entry, sliceConfig)
          );
        });

        const totalsEntry = computePrecisionTotals(entries, sliceConfig);
        if (totalsEntry) {
          precisionTableBody.appendChild(
            buildPrecisionRow(totalsEntry, sliceConfig)
          );
        }
      }

      function renderRecallTable() {
        if (!recallTableBody) {
          return;
        }

        recallTableBody.innerHTML = "";

        const scaleKey = getSelectedScaleKey();
        const scaleData = getRevisionScaleData(revisionDataCache, scaleKey);
        const breakdownKey = getSelectedBreakdown(recallBreakdownSelect);
        if (recallLabelHeading) {
          recallLabelHeading.textContent = getBreakdownHeading(
            breakdownKey,
            scaleKey
          );
        }

        const entries = getBreakdownEntries(
          revisionDataCache,
          breakdownKey,
          scaleKey
        );
        const factor = computeMistakeRepetitionFactor(scaleData);

        if (!entries || entries.length === 0) {
          if (recallEmpty) {
            recallEmpty.hidden = false;
          }
          const row = document.createElement("tr");
          const cell = document.createElement("td");
          cell.colSpan = 6;
          cell.className = "muted";
          cell.textContent = "No autograder mistake data available.";
          row.appendChild(cell);
          recallTableBody.appendChild(row);
          return;
        }

        if (recallEmpty) {
          recallEmpty.hidden = true;
        }

        const sortedEntries = entries
          .slice()
          .sort(
            (a, b) =>
              (b.autograder_wrong_total ?? 0) - (a.autograder_wrong_total ?? 0)
          );

        sortedEntries.forEach((entry) => {
          recallTableBody.appendChild(buildRecallRow(entry, factor));
        });

        const totalsEntry = computeRecallTotals(entries);
        if (totalsEntry) {
          recallTableBody.appendChild(buildRecallRow(totalsEntry, factor));
        }
      }

      function updateRevisionInsights(revision) {
        if (!revisionSection) {
          return;
        }

        revisionDataCache = revision;
        updateBreakdownScaleSelectOptions();
        renderSummaryCards();

        if (!revision) {
          revisionSection.hidden = true;
          if (recallSection) {
            recallSection.hidden = true;
          }
          if (revisionRateEl) {
            revisionRateEl.textContent = "--";
          }
          if (revisionVolumeEl) {
            revisionVolumeEl.textContent = "--";
          }
          if (revisionTotalEl) {
            revisionTotalEl.textContent = "--";
          }
          if (revisionPrecisionEl) {
            revisionPrecisionEl.textContent = "--";
          }
          if (revisionPrecisionDetailEl) {
            revisionPrecisionDetailEl.textContent = "--";
          }
          if (revisionPrecisionFootnoteEl) {
            revisionPrecisionFootnoteEl.textContent = "No revisions recorded.";
          }
          if (autograderRecallEl) {
            autograderRecallEl.textContent = "--";
          }
          if (autograderRecallDetailEl) {
            autograderRecallDetailEl.textContent = "--";
          }
          if (autograderRecallFootnoteEl) {
            autograderRecallFootnoteEl.textContent =
              "No autograder mistake data available.";
          }
          if (revisionCaseChartEl) {
            revisionCaseChartEl.innerHTML = "";
            const message = document.createElement("div");
            message.className = "muted";
            message.textContent = "No revisions recorded in this dataset.";
            revisionCaseChartEl.appendChild(message);
          }
          if (autograderRecallChartEl) {
            autograderRecallChartEl.innerHTML = "";
            const message = document.createElement("div");
            message.className = "muted";
            message.textContent = "No autograder mistakes recorded.";
            autograderRecallChartEl.appendChild(message);
          }
          renderPrecisionTable();
          renderRecallTable();
          return;
        }

        revisionSection.hidden = false;
        if (recallSection) {
          recallSection.hidden = false;
        }

        renderRevisionOverview();
        renderPrecisionTable();
        renderRecallTable();
      }

      function updatePromptTable(entries) {
        promptTableBody.innerHTML = "";

        if (!entries || entries.length === 0) {
          promptEmpty.hidden = false;
          const row = document.createElement("tr");
          const cell = document.createElement("td");
          cell.colSpan = 5;
          cell.className = "muted";
          cell.textContent = "No prompt data";
          row.appendChild(cell);
          promptTableBody.appendChild(row);
          return;
        }

        promptEmpty.hidden = true;

        entries
          .slice()
          .sort((a, b) => a.prompt_id.localeCompare(b.prompt_id))
          .forEach((entry) => {
            const row = document.createElement("tr");

            const promptCell = document.createElement("td");
            promptCell.textContent = entry.prompt_id;
            row.appendChild(promptCell);

            const countCell = document.createElement("td");
            countCell.textContent = formatCount(entry.count);
            row.appendChild(countCell);

            const autoCell = document.createElement("td");
            autoCell.textContent = formatPercent(entry.autograder_accuracy);
            row.appendChild(autoCell);

            const humanCell = document.createElement("td");
            humanCell.textContent = formatPercent(entry.human_accuracy);
            row.appendChild(humanCell);

            const deltaCell = document.createElement("td");
            if (
              entry.autograder_accuracy !== null &&
              entry.autograder_accuracy !== undefined &&
              entry.human_accuracy !== null &&
              entry.human_accuracy !== undefined
            ) {
              const diff = entry.autograder_accuracy - entry.human_accuracy;
              const badge = document.createElement("span");
              badge.classList.add("pill");
              badge.textContent = `${diff > 0 ? "+" : ""}${(diff * 100).toFixed(1)}%`;
              badge.title = "Autograder accuracy minus human accuracy";
              badge.setAttribute(
                "aria-label",
                `Autograder minus human accuracy: ${(diff * 100).toFixed(1)}%`
              );
              deltaCell.appendChild(badge);
            } else {
              deltaCell.textContent = "--";
            }
            row.appendChild(deltaCell);

            promptTableBody.appendChild(row);
          });
      }

      async function fetchJson(path) {
        const response = await fetch(path, { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`Failed to load ${path} (${response.status})`);
        }
        return response.json();
      }

      async function loadMetrics() {
        try {
          const data = await fetchJson("accuracy.json");
          accuracyDataCache = data;
          if (errorEl) {
            errorEl.hidden = true;
            errorEl.textContent = "";
          }
          updateBreakdownScaleSelectOptions();
          renderSummaryCards();
        } catch (error) {
          console.error(error);
          accuracyDataCache = null;
          if (errorEl) {
            errorEl.hidden = false;
            errorEl.textContent =
              "We were unable to load the latest accuracy metrics. Confirm that accuracy.json has been generated.";
          }
          updateCards({});
          updatePromptTable([]);
          updateBreakdownScaleSelectOptions();
          updateRevisionInsights(null);
          return;
        }

        try {
          const revisionData = await fetchJson("revision.json");
          updateRevisionInsights(revisionData);
        } catch (error) {
          console.error(error);
          updateRevisionInsights(null);
        }
      }

      loadMetrics();
    </script>
  </body>
</html>
